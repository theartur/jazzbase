// listen for JSON input
// store json input
// retrieve JSON input
// queue transactions via internal
//  - every IO must be processed through a queue
//  - an active shifter reads and process in order
//  
// TODO
// - memory cache
// - batch io

var fs = require('fs');
var http = require('http');
var url = require('url');

var channels = {store: {}};
var jazzbaseCallbacks = {};

var ioQueue = [];

function readStores() {
    var files = fs.readdirSync(".");
    var channelsAvailable = [];

    files.forEach(function (item) {
        var channel;
        if (item.indexOf('jazzbase-') > -1 && item.indexOf('.json') > -1) {
            channel = item.substr('jazzbase-'.length, item.length - '.json'.length - 'jazzbase-'.length);
            channelsAvailable.push(channel);
        }
    });

    channelsAvailable.forEach(function (channel) {
        var channelData = fs.readFileSync('jazzbase-' + channel + '.json', 'utf8');
        channels[channel] = JSON.parse(channelData);
    });
}

function listenRemote(port) {
    try {
        http.createServer(function (req, res) {
            var clientIP = getReqIP(req);

            res.writeHead(200, {
                'Content-Type': 'application/json',
                'Access-Control-Allow-Origin': '*'
            });

            var toPush = url.parse(req.url, true).query.push ||  null;

            var channel = url.parse(req.url, true).query.channel ||  null;
            var key = url.parse(req.url, true).query.key ||  null;
            var data = url.parse(req.url, true).query.data ||  null;
            var out = '';
            
            var opPush = !data && toPush && channel && key;
            var opSet = !toPush && data && channel && key;
            var opGet = channel && key;

            if (opPush) {
                console.log(new Date() + " " + clientIP + " PUSH :: ", channel, key, toPush);
                try {
                    toPush = JSON.parse(toPush);
                } catch(e) {}
                jazzbaseQueuePush(channel, key, toPush, onOpEnd);
                
            } else if (opSet) {
                console.log(new Date() + " " + clientIP + " SET :: ", channel, key, data);
                try {
                    data = JSON.parse(data);
                } catch(e) {}
                
                jazzbaseQueueSet(channel, key, data, onOpEnd);
                
            } else if (opGet) {
                console.log(new Date() + " " + clientIP + " GET :: ", channel, key);
                jazzbaseQueueGet(channel, key, onOpEnd);
                
            } else {
                res.end("error: invalid jazzbase request");
            }
            
            function onOpEnd(err, data) {
                var out;
                
                if (data && typeof data == "object") {
                    out = err || JSON.stringify(data);
                } else {
                    out = err || data;
                }

                console.log(new Date() + " " + clientIP + " :: Response: " + out);

                res.end(out ? out+"" : "");
            }
        }).listen(port);
    } catch(e) {
        console.log("@@@@@@@@@", Object.keys(e));
        throw new Error("BOOM!");
    }

    console.log("Listening on " + port + " ...");
}

function getReqIP(req) {
    return req.headers['x-forwarded-for'] || 
     req.connection.remoteAddress || 
     req.socket.remoteAddress ||
     req.connection.socket.remoteAddress;
}

function readChannel(channel, returns) {
    return fs.readFile('jazzbase-' + channel + '.json', 'utf8', function (err, jsonChannel) {
        if (jsonChannel) {
            jsonChannel = jsonChannel.toString();
            try {
                var parsed = JSON.parse(jsonChannel);
                returns(err, parsed);
            } catch(e) {
                returns(e);
            }
        } else {
            returns(jsonChannel);
        }
    });
}

function writeChannel(channel, key, data, push, returns) {
    readChannel(channel, function (err, db) {
        db = db || {};
        if (push) {
            db[key] = db[key] || [];
            db[key].push(data);
        } else {
            db[key] = data;
        }

        try {
            var strDB = JSON.stringify(db);

            fs.writeFile(getJazzbaseChannelFile(channel), strDB, returns);
        } catch (e) {
            returns(e);
        }
    });
}

function writeModComm(key, data, returns) {
    try {
        fs.writeFile("node_modules/modComm/" + key + ".js", JSON.stringify(data), returns);
    } catch (e) {
        fs.writeFile("node_modules/modComm/" + key + ".js", data, returns);
    }
}

function getJazzbaseChannelFile (channel) {
    return './jazzbase-' + (channel || 'store') + '.json';
}

function jazzbaseGet(channel, key, returns) {
    return readChannel(channel, function(err, db){
        if ( !err && db) {
            returns(null, db[key]);
        } else {
            returns(err, null);
        }
    });
}

function jazzbaseSet(channel, key, data, returns) {
    writeChannel(channel, key, data, false, returns);
}

function jazzbasePush(channel, key, data, returns) {
    writeChannel(channel, key, data, true, returns);
}

function processTask(task, returns) {
    if (task.io == 'set') {
        return jazzbaseSet(task.channel, task.key, task.data, returns);
        
    } else if (task.io == 'get') {
        return jazzbaseGet(task.channel, task.key, returns);
        
    } else if (task.io == 'push') {
        return jazzbasePush(task.channel, task.key, task.data, returns);
        
    } else {
        return null;
    }
}

var activeProcessQueue = false;
function processQueue(force) {
    if ( ! activeProcessQueue || force) {
        activeProcessQueue = true;
        var task = ioQueue.shift();
        if (task) {
            processTask(task, function () {
                task.returns.apply(this, arguments);
                processQueue(true);
            });
        } else {
            activeProcessQueue = false;
        }
    }
}

function queueTask(task) {
    ioQueue.push(task);
    processQueue();
}

function jazzbaseQueueGet(channel, key, returns) {
    if (channel == "modComm") {
        writeModComm(key, data, returns);
    } else {
        queueTask({io:'get', channel:channel, key:key, returns:returns});
    }
}

function jazzbaseQueueSet(channel, key, data, returns) {
    queueTask({io:'set', channel:channel, key:key, data:data, returns:returns});
}

function jazzbaseQueuePush(channel, key, data, returns) {
    queueTask({io:'push', channel:channel, key:key, data:data, returns:returns});
}

function jazzbase(channel) {
    return {
        get: function (key, returns) {
            jazzbaseQueueGet(channel, key, returns);
        },
        set: function (key, data, returns) {
            jazzbaseQueueSet(channel, key, data, returns);
        },
        push: function (key, data, returns) {
            jazzbaseQueuePush(channel, key, data, returns);
        },
        listen: function (port) {
            listenRemote(port);
        }
    };
}

module.exports = jazzbase;