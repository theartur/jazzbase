var startTime = +new Date;

var fs = require("fs");
var stream = require('stream');
var util = require('util');

var channels = {};
var channelOutput = {};

var persists = 0;

//function setupPersistence() {
    function StringifyStream(){
        stream.Transform.call(this);

        this._readableState.objectMode = false;
        this._writableState.objectMode = true;
    }

    util.inherits(StringifyStream, stream.Transform);

    StringifyStream.prototype._transform = function(obj, encoding, cb){
        this.push(JSON.stringify(obj));
        cb();
    };
//}

function throttle(fn, delta) {
    var timeout, last = +new Date;
    return function () {
        var diff = (+new Date) - last, self = this, args = arguments;

        function run () {
            fn.apply(self, args);
        }
        
        if (diff >= delta) {
            clearTimeout(timeout);
            run();
            last = +new Date;
        } else {
            clearTimeout(timeout);
            timeout = setTimeout(function(){
                run();
            }, delta);
        }
    };
}

var warnStillRunning = throttle(function (setsDone) {
    console.log("still running: ", setsDone);
}, 10000);

var warnRunningNow = throttle(function (setsDone) {
    console.log("running now: ", setsDone);
}, 1000);

function debounce(fn, delta) {
    var timeout, running = false;
    
    return function () {
        var self = this, args = arguments;

        function run () {
//             console.log("callback()", Object.keys(args[1]).length);
            
            Array.prototype.push.call(args, function endCallback() {
                console.log("x close write stream");
                running = false;
            });
            
            console.log("O open write stream");
            running = true;
            
            fn.apply(self, args);
        }
        
        var setsCount = Object.keys(args[1]).length;

        if ( ! running) {
            warnRunningNow(setsCount);
            clearTimeout(timeout);
            run();
        } else {
            warnStillRunning(setsCount);
            
            clearTimeout(timeout);
            timeout = setTimeout(function(){
                run();
            }, delta);
        }
    };
}

function persist(channel, jsonObj) {
    var readStream = new stream.Readable({ objectMode: true });
    readStream.push(jsonObj);
    readStream.push(null);
    
// console.log("persists", persists++);
    
    var strfy = new StringifyStream();
    var output = writeChannel(channel);// channelOutput[channel];

//     if stream is not open, open one and pipe
    
    var callback = arguments[arguments.length-1];
    
    if (typeof callback == 'function') {
        output.on('finish', callback);
    }
    
    readStream
        .pipe(strfy)
        .pipe(output);
}

function writeChannel(channel) {
    var stream = fs.createWriteStream(channel + '.json');
    stream.setMaxListeners(0);
    return stream;
}

function jazzbase(channel) {
    var debounceDelta = 1000;
    
//     channelOutput[channel] = fs.createWriteStream(channel + '.json');
//     channelOutput[channel].setMaxListeners(0);
    
    console.log("debounceDelta", debounceDelta);
    
    try {
        channels[channel] = require(channel + ".json");
    } catch(e) {
        channels[channel] = {};
    }
    
    var debouncedPersist = debounce(persist, debounceDelta);
    
    return {
        get: function (key) {
            return channels[channel][key];
        },
        set: function (key, data) {
            channels[channel][key] = data;
            debouncedPersist(channel, channels[channel]);
            
//             https://github.com/dominictarr/JSONStream
//             throttle(fs.writeFile, 250)(channel + ".json", JSON.stringify(channels[channel]));
        },
    };
}

module.exports = jazzbase;